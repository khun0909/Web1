<!DOCTYPE html>
<html>
<head>
  <title>Tetris</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    #game-board {
      width: 300px;
      height: 600px;
      background-color: #f1f1f1;
      border: 2px solid #ccc;
      margin: 0 auto;
      position: relative;
    }
    .block {
      width: 29px;
      height: 29px;
      background-color: #333;
      border: 1px solid #000;
      position: absolute;
    }
    .solid-block {
      animation: none;
    }
  </style>
</head>
<body>
  <div id="game-board"></div>

  <script>
    // 게임 보드 크기
    const rows = 20;
    const columns = 10;

    // 테트리스 모양 정의
    const shapes = [
      [[1, 1, 1, 1]],
      [[1, 1], [1, 1]],
      [[1, 1, 0], [0, 1, 1]],
      [[0, 1, 1], [1, 1, 0]],
      [[1, 1, 1], [0, 1, 0]],
      [[1, 1, 1], [1, 0, 0]],
      [[1, 1, 1], [0, 0, 1]],
    ];

    let gameBoard = [];
    let currentShape;
    let currentShapeRow;
    let currentShapeColumn;
    let gameInterval;

    // 게임 보드 초기화
    function initializeGameBoard() {
      for (let row = 0; row < rows; row++) {
        gameBoard[row] = [];
        for (let col = 0; col < columns; col++) {
          gameBoard[row][col] = 0;
        }
      }
    }

    // 새로운 블록 생성
    function generateNewShape() {
      const shapeIndex = Math.floor(Math.random() * shapes.length);
      const shape = shapes[shapeIndex];

      currentShape = shape;
      currentShapeRow = 0;
      currentShapeColumn = Math.floor(columns / 2) - Math.floor(shape[0].length / 2);
    }

    // 블록 그리기
    function drawShape() {
      for (let row = 0; row < currentShape.length; row++) {
        for (let col = 0; col < currentShape[row].length; col++) {
          if (currentShape[row][col]) {
            const block = document.createElement('div');
            block.className = 'block';
            block.style.top = (currentShapeRow + row) * 30 + 'px';
            block.style.left = (currentShapeColumn + col) * 30 + 'px';
            document.getElementById('game-board').appendChild(block);
          }
        }
      }
    }

    // 그려진 블록들 그리기
    function drawBlocks() {
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
          if (gameBoard[row][col]) {
            const block = document.createElement('div');
            block.className = 'block solid-block';
            block.style.top = row * 30 + 'px';
            block.style.left = col * 30 + 'px';
            document.getElementById('game-board').appendChild(block);
          }
        }
      }
    }

    // 블록 지우기
    function eraseShape() {
      const blocks = document.getElementsByClassName('block');
      while (blocks[0]) {
        blocks[0].parentNode.removeChild(blocks[0]);
      }
    }

    // 게임 업데이트
    function updateGame() {
      eraseShape();
      currentShapeRow++;

      if (!isCollision()) {
        drawShape();
      } else {
        currentShapeRow--;
        drawShape();
        mergeShape();
        checkFullRows();
        generateNewShape();

        if (isGameOver()) {
          clearInterval(gameInterval);
          alert('Game Over');
        }
      }

      drawBlocks();
    }

    // 블록 합치기
    function mergeShape() {
      for (let row = 0; row < currentShape.length; row++) {
        for (let col = 0; col < currentShape[row].length; col++) {
          if (currentShape[row][col]) {
            gameBoard[currentShapeRow + row][currentShapeColumn + col] = 1;
          }
        }
      }
    }

    // 행이 꽉 찼는지 확인하고 삭제
    function checkFullRows() {
      for (let row = rows - 1; row >= 0; row--) {
        if (gameBoard[row].every(block => block === 1)) {
          gameBoard.splice(row, 1);
          gameBoard.unshift(new Array(columns).fill(0));
        }
      }
    }

    // 충돌 검사
    function isCollision() {
      for (let row = 0; row < currentShape.length; row++) {
        for (let col = 0; col < currentShape[row].length; col++) {
          if (
            currentShape[row][col] &&
            (currentShapeRow + row >= rows ||
              currentShapeColumn + col < 0 ||
              currentShapeColumn + col >= columns ||
              gameBoard[currentShapeRow + row][currentShapeColumn + col] === 1)
          ) {
            return true;
          }
        }
      }
      return false;
    }

    // 게임 오버 검사
    function isGameOver() {
      return gameBoard[0].some(block => block === 1);
    }

    // 키보드 입력 처리
    function handleKeyPress(event) {
      switch (event.key) {
        case 'ArrowLeft':
          moveShapeLeft();
          break;
        case 'ArrowRight':
          moveShapeRight();
          break;
        case 'ArrowDown':
          moveShapeDown();
          break;
        case ' ':
          dropShape();
          break;
        case 'ArrowUp':
          rotateShape();
          break;
      }
    }

    // 블록 왼쪽으로 이동
    function moveShapeLeft() {
      eraseShape();
      currentShapeColumn--;

      if (isCollision()) {
        currentShapeColumn++;
      }

      drawShape();
    }

    // 블록 오른쪽으로 이동
    function moveShapeRight() {
      eraseShape();
      currentShapeColumn++;

      if (isCollision()) {
        currentShapeColumn--;
      }

      drawShape();
    }

    // 블록 아래로 이동
    function moveShapeDown() {
      eraseShape();
      currentShapeRow++;

      if (isCollision()) {
        currentShapeRow--;
      }

      drawShape();
    }

    // 블록 한 번에 내려가기
    function dropShape() {
      eraseShape();

      while (!isCollision()) {
        currentShapeRow++;
      }

      currentShapeRow--;
      drawShape();

      mergeShape();
      checkFullRows();
      generateNewShape();
    }

    // 블록 회전하기
    function rotateShape() {
      eraseShape();

      const previousShape = currentShape;
      currentShape = rotateMatrix(currentShape);

      if (isCollision()) {
        currentShape = previousShape;
      }

      drawShape();
    }

    // 행렬 회전하기
    function rotateMatrix(matrix) {
      const numRows = matrix.length;
      const numCols = matrix[0].length;

      const result = [];
      for (let col = 0; col < numCols; col++) {
        const newRow = [];
        for (let row = numRows - 1; row >= 0; row--) {
          newRow.push(matrix[row][col]);
        }
        result.push(newRow);
      }

      return result;
    }

    // 게임 시작
    function startGame() {
      initializeGameBoard();
      generateNewShape();
      drawShape();
      gameInterval = setInterval(updateGame, 500); // 0.5초마다 게임 업데이트

      // 키보드 입력 이벤트 리스너 추가
      document.addEventListener('keydown', handleKeyPress);
    }

    startGame();
  </script>
</body>
</html>
